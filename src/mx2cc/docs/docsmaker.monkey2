
Namespace mx2.docs

Const PAGES_DIR:="docs/__PAGES__/"

Class DocsMaker

	Method New()
	
		_nav=New JsonBuffer
	
		_md=New MarkdownBuffer( Lambda:String( link:String )
			Return ResolveLink( link,_linkScope )
		End )
		
	End
	
	Method MakeDocs:String( module:Module )
	
		_module=module
		
		_pagesDir=_module.baseDir+PAGES_DIR
		_pageTemplate=stringio.LoadString( "docs/modules_page_template.html" )
		
		DeleteDir( _pagesDir,True )
		CreateDir( _pagesDir,True )

		Local nmspaces:=New StringMap<NamespaceScope>
		
		Local nmspaceDocs:=New StringMap<String>
		
		For Local fscope:=Eachin _module.fileScopes
		
			Local nmspace:=Cast<NamespaceScope>( fscope.outer )
			If Not nmspace Continue
			
			nmspaces[nmspace.Name]=nmspace
			nmspaceDocs[nmspace.Name]+=fscope.fdecl.docs
		Next
		
		Local page:=""
		Local mdocs:=_module.baseDir+"docs/module.md"
		If GetFileType( mdocs )=FileType.File
			Local md:=stringio.LoadString( mdocs )
			_linkScope=Null
			_md.Emit( md )
			page="module"
'			page=_module.name+"-Default"
			SavePage( _md.Flush(),page )
		Endif

		BeginNode( _module.name,page )
		
		For Local nmspace:=Eachin nmspaces.Values
			EmitNamespace( nmspace,nmspaceDocs[nmspace.Name] )
		Next
		
		EndNode()
		
		Local tree:=_nav.Flush()
		
		stringio.SaveString( tree,_pagesDir+"index.js" )

		Return tree
	End
	
	'Kludgy as!
	'
	'Converts the 'TOC' tree generated by stackedit into a json nav tree...
	'
	Method MakeLangNav:String()
	
		#rem
		Local md:=stringio.LoadString( "docs/The Monkey2 Language.md" )
		_md.Emit( md )
		Local html:=_md.Flush()
		
		Local src:=stringio.LoadString( "docs/monkey2-language-template.html" )
		src=src.Replace( "${CONTENT}",html )
		
		stringio.SaveString( src,"docs/The Monkey2 Language.html" )
		#End
		
		Local src:=stringio.LoadString( "docs/The Monkey2 Language.html" )
		
		src=src.Replace( "~r~n","~n" )
		
		Local tag1:="<p><div class=~qtoc~q>"
		Local tag2:="</div>"
		
		Local i:=src.Find( tag1 )
		If i=-1
			Print "Can't find lang TOC div"
			Return ""
		Endif

		Local i2:=src.Find( tag2,i+tag1.Length )
		If i2=-1
			Print "Can't find lang TOC /div"
			Return ""
		Endif
		
		src=src.Slice( i+tag1.Length,i2 )
		
		Local nest:=0
		
		For Local line:=Eachin src.Split( "~n" )
		
			If line="</ul>"
			
				If nest
					_nav.Emit( "]}" )
					nest-=1
				Endif
			
			Else If line="</li>"
			
			Else If line.StartsWith( "<li>" )
			
				Local i:=line.Find( "<a href=~q#" )
				If i=-1 Continue
				Local i2:=line.Find( "~q>",i+10 )
				If i2=-1 Continue
				Local i3:=line.Find( "</a>",i2+2 )
				If i3=-1 Continue
				
				Local href:=line.Slice( i+10,i2 )
				Local text:=line.Slice( i2+2,i3 )
				
				If line.EndsWith( "<ul>" )
					nest+=1
					_nav.Emit( "{text:~q"+text+"~q,data:{topic:~q"+href+"~q},children:[" )
				Else If line.EndsWith( "</li>" )
					_nav.Emit( "{text:~q"+text+"~q,data:{topic:~q"+href+"~q}}" )
				Endif
				
			Endif
			
		Next
		
		Local tree:=_nav.Flush()
		
		Return tree
	End
	
	Private
	
	Field _nav:JsonBuffer
	
	Field _md:MarkdownBuffer

	Field _module:Module
	
	Field _pagesDir:String			'module/docs
	Field _pageTemplate:String
	
	Field _linkScope:Scope

	Method Esc:String( id:String )
		id=id.Replace( "|","\|" )
		id=id.Replace( "_","\_" )
		id=id.Replace( "<","\<" )
		id=id.Replace( ">","\>" )
		Return id
	End	
	
	Method DeclPath:String( decl:Decl,scope:Scope )
	
		Local ident:=decl.ident.Replace( "@","" )
		If Not IsIdent( ident[0] ) ident=OpSym( ident )
		
		Local slug:=scope.Name+"."+ident
		
		Repeat
			Local i:=slug.Find( "<" )
			If i=-1 Exit
			Local i2:=slug.Find( ">",i+1 )
			If i2=-1 Exit
			slug=slug.Slice( 0,i )+slug.Slice( i2+1 )
		Forever
		
		Return slug
	End
	
	Method NamespacePath:String( nmspace:NamespaceScope )
	
		Return nmspace.Name
	End
	
	Method DeclSlug:String( decl:Decl,scope:Scope )

		Local module:=scope.FindFile().fdecl.module.name

		Local slug:=module+":"+DeclPath( decl,scope ).Replace( ".","-" )
		
		Return slug
	End
	
	Method NamespaceSlug:String( nmspace:NamespaceScope )
	
		Local slug:=_module.name+":"+NamespacePath( nmspace ).Replace( ".","-" )
		
		Return slug
	End
	
	Method MakeLink:String( text:String,decl:Decl,scope:Scope )
	
		Local slug:=DeclSlug( decl,scope )
		
		Return "<a href=~qjavascript:void('"+slug+"')~q onclick=~qopenDocsPage('"+slug+"')~q>"+text+"</a>"
	End
	
	Method MakeLink:String( text:String,nmspace:NamespaceScope )
	
		Local slug:=NamespaceSlug( nmspace )
		
		Return "<a href=~qjavascript:void('"+slug+"')~q onclick=~qopenDocsPage('"+slug+"')~q>"+text+"</a>"
	End

	Method ResolveLink:String( path:String,scope:Scope )
	
		Local i0:=0
		
		Local tpath:=""
		
		Repeat
		
			Local i1:=path.Find( ".",i0 )
			If i1=-1
			
				If Not scope Return ""

				Local id:=path.Slice( i0 )
				
				Local node:=scope.FindNode( id )
				If Not node
					Return path
				Endif
				
				tpath+=id
				
				Local vvar:=Cast<VarValue>( node )
				If vvar Return MakeLink( tpath,vvar.vdecl,vvar.scope )
				
				Local flist:=Cast<FuncList>( node )
				If flist Return MakeLink( tpath,flist.funcs[0].fdecl,flist.funcs[0].scope )
				
				Local etype:=TCast<EnumType>( node )
				If etype Return MakeLink( tpath,etype.edecl,etype.scope.outer )
				
				Local ntype:=TCast<NamespaceType>( node )
				If ntype Return MakeLink( tpath,ntype.scope )
				
				Local ctype:=TCast<ClassType>( node )
				If ctype Return MakeLink( tpath,ctype.cdecl,ctype.scope.outer )
				
				Return ""
			Endif
			
			Local id:=path.Slice( i0,i1 )
			i0=i1+1
			
			Local type:Type
			If scope
				Try
					type=scope.FindType( id )
				Catch ex:SemantEx
					Print "Exception!"
				End
			Else If Not tpath
				For Local fscope:=Eachin _module.fileScopes
					If id<>fscope.nmspace.ntype.ident Continue
					type=fscope.nmspace.ntype
					Exit
				Next
			Endif

			If Not type 
				Return path
			Endif
			
			tpath+=id+"."
			
			Local ntype:=TCast<NamespaceType>( type )
			If ntype
				scope=ntype.scope
				Continue
			Endif
			
			Local ctype:=TCast<ClassType>( type )
			If ctype
				scope=ctype.scope
				Continue
			Endif
			
			Local etype:=TCast<EnumType>( type )
			If etype
				'stop at Enum!
				Return MakeLink( tpath+"."+path.Slice( i0 ),etype.edecl,etype.scope.outer )
			Endif
			
			Return ""
			
		Forever
			
		Return ""
	End
	
	Method DeclIdent:String( decl:Decl,gen:Bool=False )

		Local ident:=decl.ident
		
		If decl.IsOperator
			ident="Operator "+ident
		Else If ident="new"
			ident="New"
		Else If ident.StartsWith( "@" )
			ident=ident.Slice( 1 ).Capitalize()
		Endif
		
		If gen
			Local adecl:=Cast<AliasDecl>( decl )
			If adecl And adecl.genArgs ident+="<"+(",".Join( adecl.genArgs ))+">"
			
			Local cdecl:=Cast<ClassDecl>( decl )
			If cdecl And cdecl.genArgs ident+="<"+(",".Join( cdecl.genArgs ))+">"
			
			Local fdecl:=Cast<FuncDecl>( decl )
			If fdecl And fdecl.genArgs ident+="<"+(",".Join( fdecl.genArgs ))+">"
		Endif
		
		Return Esc( ident )
	End
	
	Method DeclIdent:String( decl:Decl,scope:Scope,gen:Bool=False )

		Return MakeLink( DeclIdent( decl,gen ),decl,scope )
	End
	
	Method DeclName:String( decl:Decl,scope:Scope )
	
		Local path:=""
		Local nmspace:=scope.FindFile().nmspace
		
		While scope<>nmspace
			If Not scope Return "?????"
			Local cscope:=Cast<ClassScope>( scope )
			If cscope
				Local decl:=cscope.ctype.cdecl
				path=DeclIdent( decl,cscope.outer,True )+"."+path
			Endif
			scope=scope.outer
		Wend
		
		If path path=path.Slice( 0,-1 )+"."
		
		Return path+DeclIdent( decl )
	End
	
	Method DeclDesc:String( decl:Decl )
		Local desc:=decl.docs
		Local i:=desc.Find( "~n" )
		If i<>-1 desc=desc.Slice( 0,i )
'		desc=Esc( desc )
		Return desc
	End
	
	Method SavePage( docs:String,page:String )
		page=page.Replace( ".","-" )
		docs=_pageTemplate.Replace( "${CONTENT}",docs )
		
'		Print "Saving page:"+_pagesDir+page+".html"
		
		stringio.SaveString( docs,_pagesDir+page+".html" )
	End
	
	Method TypeName:String( type:Type,prefix:String )
	
		Local xtype:=Cast<AliasType>( type )
		If xtype
		
			If xtype.instanceOf xtype=xtype.instanceOf
			
			Return MakeLink( Esc( xtype.adecl.ident ),xtype.adecl,xtype.scope )
		Endif
	
		Local vtype:=TCast<VoidType>( type )
		If vtype
			Return vtype.Name
		Endif
	
		Local gtype:=TCast<GenArgType>( type )
		If gtype
			Return gtype.Name.Replace( "?","" )
		Endif
	
		Local ptype:=TCast<PrimType>( type )
		If ptype
			Local ctype:=ptype.ctype
			Return MakeLink( Esc( ptype.Name ),ctype.cdecl,ctype.scope.outer )
		Endif
		
		Local ntype:=TCast<NamespaceType>( type )
		If ntype
			Return Esc( ntype.Name )
		Endif
		
		Local ctype:=TCast<ClassType>( type )
		If ctype
			Local args:=""
			For Local type:=Eachin ctype.types
				args+=","+TypeName( type,prefix )
			Next
			If args args="\< "+args.Slice( 1 )+" \>"
			
			If ctype.instanceOf ctype=ctype.instanceOf
			
			Return MakeLink( Esc( ctype.cdecl.ident ),ctype.cdecl,ctype.scope.outer )+args
		Endif
		
		Local etype:=TCast<EnumType>( type )
		If etype
			Local name:=etype.Name
			If name.StartsWith( prefix ) name=name.Slice( prefix.Length )
			Return MakeLink( Esc( name ),etype.edecl,etype.scope.outer )
		Endif
		
		Local qtype:=TCast<PointerType>( type )
		If qtype
			Return TypeName( qtype.elemType,prefix )+" Ptr"
		Endif
		
		Local atype:=TCast<ArrayType>( type )
		If atype
			If atype.rank=1 Return TypeName( atype.elemType,prefix )+"\[ \]"
			Return TypeName( atype.elemType,prefix )+"\[ ,,,,,,,,,".Slice( 0,atype.rank+2 )+" \]"
		End
		
		Local ftype:=TCast<FuncType>( type )
		If ftype
			Local args:=""
			For Local arg:=Eachin ftype.argTypes
				args+=","+TypeName( arg,prefix )
			Next
			args=args.Slice( 1 )
			Return TypeName( ftype.retType,prefix )+"( "+args+" )"
		Endif
		
		Print type.Name+"!!!!!!"
		Assert( False )
		Return ""
	End
	
	Method TypeName:String( type:Type,scope:Scope )
		Local prefix:=scope.FindFile().nmspace.Name+"."
		Return TypeName( type,prefix )
	End
	
	Method EmitHeader( decl:Decl,scope:Scope )
		Local fscope:=scope.FindFile()
		Local nmspace:=fscope.nmspace
		Local module:=fscope.fdecl.module
		_md.Emit( "_Module: &lt;"+module.name+"&gt;_  " )
		_md.Emit( "_Namespace:_ _"+MakeLink( NamespacePath( nmspace ),nmspace )+"_" )
		_md.EmitBr()
		_md.Emit( "#### "+DeclName( decl,scope ) )
		_md.EmitBr()
	End
	
	Method DocsHidden:Bool( decl:Decl )
		Return (decl.IsPrivate And Not decl.docs) Or decl.docs.StartsWith( "@hidden" )
	End
	
	Method EmitMembers( kind:String,scope:Scope,inherited:Bool )
	
		Local init:=True
	
		For Local node:=Eachin scope.nodes
		
			Local atype:=Cast<AliasType>( node.Value )
			If atype
				If kind<>"alias" Continue
				Local decl:=atype.adecl
				If DocsHidden( decl ) Continue
				If inherited<>(scope<>atype.scope) Continue
				
				If init
					init=False
					_md.EmitBr()
					_md.Emit( "| Aliases | &nbsp; |" )
					_md.Emit( "|:---|:---" )
				Endif
				
				_md.Emit( "| "+DeclIdent( decl,atype.scope )+" | "+DeclDesc( decl )+" |" )
				Continue
			Endif
				

			Local ctype:=Cast<ClassType>( node.Value )
			If ctype
				Local decl:=ctype.cdecl
				If kind<>decl.kind Continue
				If DocsHidden( decl ) Continue
				If inherited<>(scope<>ctype.scope.outer) Continue
				
				If init
					init=False
					Local kinds:=kind.Capitalize() + (kind="class" ? "es" Else "s")
					_md.EmitBr()
					_md.Emit( "| "+kinds+" | |" )
					_md.Emit( "|:---|:---|" )
				Endif
				
				_md.Emit( "| "+DeclIdent( decl,ctype.scope.outer )+" | "+DeclDesc( decl )+" |" )
				Continue
			Endif
			
			Local etype:=Cast<EnumType>( node.Value )
			If etype
				If kind<>"enum" Continue
				Local decl:=etype.edecl
				If DocsHidden( decl ) Continue
				If inherited<>(scope<>etype.scope.outer) Continue
				
				If init
					init=False
					_md.EmitBr()
					_md.Emit( "| Enums | |" )
					_md.Emit( "|:---|:---|" )
				Endif

				_md.Emit( "| "+DeclIdent( decl,etype.scope.outer )+" | "+DeclDesc( decl )+" |" )
				Continue
			Endif

			Local vvar:=Cast<VarValue>( node.Value )
			If vvar
				Local decl:=vvar.vdecl
				If kind<>decl.kind Continue
				If DocsHidden( decl ) Continue
				If inherited<>(scope<>vvar.scope) Continue

				If init
					init=False
					_md.EmitBr()
					_md.Emit( "| "+kind.Capitalize()+"s | |" )
					_md.Emit( "|:---|:---|" )
				Endif

				_md.Emit( "| "+DeclIdent( decl,vvar.scope )+" | "+DeclDesc( decl )+" |" )
				Continue
			Endif
			
			Local plist:=Cast<PropertyList>( node.Value )
			If plist
				If kind<>"property" Continue
				Local decl:=plist.pdecl
				If DocsHidden( decl ) Continue
				If inherited<>(scope<>plist.scope) Continue
				
				If init
					init=False
					_md.EmitBr()
					_md.Emit( "| Properties | |" )
					_md.Emit( "|:---|:---|" )
				Endif

				_md.Emit( "| "+DeclIdent( decl,plist.scope )+" | "+DeclDesc( decl )+" |" )
				Continue
			Endif
		
			Local flist:=Cast<FuncList>( node.Value )
			If flist
				If kind<>"constructor" And kind<>"operator" And kind<>"method" And kind<>"function" Continue

				For Local func:=Eachin flist.funcs
					Local decl:=func.fdecl
					If DocsHidden( decl ) Continue
					If inherited<>(scope<>func.scope) Continue
					
					If kind="constructor" 
						If decl.ident<>"new" Continue
					Else If kind="operator"
						If Not decl.IsOperator Continue
					Else If kind<>decl.kind Or decl.ident="new" Or decl.IsOperator
						Continue
					Endif
					
					If init
						init=False
						_md.EmitBr()
						_md.Emit( "| "+kind.Capitalize()+"s | |" )
						_md.Emit( "|:---|:---|" )
					Endif
					
					_md.Emit( "| "+DeclIdent( decl,func.scope )+" | "+DeclDesc( decl )+" |" )
					Exit
					
				Next
				Continue
			Endif
			
		Next

	End
	
	Method BeginNode( name:String,page:String="" )
	
		If page page=",data:{page:'"+_module.name+":"+page+"'}"
		
		_nav.Emit( "{ text:'"+name+"'"+page+",children:[" )

	End
	
	Method EndNode()

		_nav.Emit( "] }" )
	End
	
	Method EmitLeaf( name:String,page:String="" )
	
		If page page=",data:{page:'"+_module.name+":"+page+"'}"
		
		_nav.Emit( "{ text:'"+name+"'"+page+",children:[] }" )
		
	End
	
	Method EmitLeaf( decl:Decl,page:String="" )

		EmitLeaf( decl.ident,page )

	End
	
	Method EmitNode( decl:Decl,scope:Scope,page:String="" )
	
		EmitNode( decl.ident,scope,page )

	End
	
	Method EmitNode( name:String,scope:Scope,page:String="" )
	
		BeginNode( name,page )
	
		BeginNode( "Aliases" )
		EmitAliases( scope,"alias" )
		EndNode()
		
		BeginNode( "Enums" )
		EmitEnums( scope,"enum" )
		EndNode()
		
		BeginNode( "Structs" )
		EmitClasses( scope,"struct" )
		EndNode()		
		
		BeginNode( "Classes" )
		EmitClasses( scope,"class" )
		EndNode()
		
		BeginNode( "Interfaces" )
		EmitClasses( scope,"interface" )
		EndNode()
		
		BeginNode( "Constants" )
		EmitVars( scope,"const" )
		EndNode()

		BeginNode( "Globals" )
		EmitVars( scope,"global" )
		EndNode()
		
		BeginNode( "Fields" )
		EmitVars( scope,"field" )
		EndNode()

		BeginNode( "Contructors" )		
		EmitFuncs( scope,"constructor" )
		EndNode()
		
		BeginNode( "Properties" )
		EmitProperties( scope,"property" )
		EndNode()

		BeginNode( "Operators" )		
		EmitFuncs( scope,"operator" )
		EndNode()
		
		BeginNode( "Methods" )
		EmitFuncs( scope,"method" )
		EndNode()

		BeginNode( "Functions" )
		EmitFuncs( scope,"function" )
		EndNode()
		
		EndNode()
		
	End
	
	Method EmitNamespace( nmspace:NamespaceScope,docs:String )

		_linkScope=nmspace
	
		_md.Emit( "_Module: &lt;"+_module.name+"&gt;_  " )
		_md.Emit( "_Namespace: "+nmspace.Name+"_" )
		
		EmitMembers( "alias",nmspace,True )
		EmitMembers( "enum",nmspace,True )
		EmitMembers( "struct",nmspace,True )
		EmitMembers( "class",nmspace,True )
		EmitMembers( "interface",nmspace,True )
		EmitMembers( "const",nmspace,True )
		EmitMembers( "global",nmspace,True )
		EmitMembers( "function",nmspace,True )
		
		_md.Emit( docs )

		docs=_md.Flush()
		
		Local page:=NamespacePath( nmspace )
		SavePage( docs,page )
		
		EmitNode( nmspace.ntype.Name,nmspace,page )
	End
	
	Method EmitVars( scope:Scope,kind:String )
	
		For Local node:=Eachin scope.nodes
	
			Local vvar:=Cast<VarValue>( node.Value )
			If Not vvar Or vvar.transFile.module<>_module Continue
			
			Local decl:=vvar.vdecl
			If decl.kind<>kind Or DocsHidden( decl ) Continue
		
			_linkScope=vvar.scope

			EmitHeader( decl,vvar.scope )
		
			_md.Emit( "##### "+decl.kind.Capitalize()+" "+DeclIdent( decl )+" : "+TypeName( vvar.type,vvar.scope ) )
		
			_md.Emit( decl.docs )
		
			Local docs:=_md.Flush()

			Local page:=DeclPath( vvar.vdecl,vvar.scope )
			SavePage( docs,page )
			
'			Print "save page:"+page
			
			EmitLeaf( vvar.vdecl,page )
			
		Next
	
	End
	
	Method EmitAliases( scope:Scope,kind:String )
	
		For Local node:=Eachin scope.nodes
		
			Local atype:=Cast<AliasType>( node.Value )
			If Not atype Continue
			
			Local decl:=atype.adecl
			If decl.kind<>kind Or DocsHidden( decl ) Continue
		
			_linkScope=atype.scope
		
			EmitHeader( decl,atype.scope )
		
			_md.Emit( "##### Alias "+DeclIdent( decl,True )+" : "+TypeName( atype._alias,atype.scope ) )
		
			_md.Emit( decl.docs )
		
			Local docs:=_md.Flush()

			Local page:=DeclPath( atype.adecl,atype.scope )
			SavePage( docs,page )
			
			EmitLeaf( atype.adecl,page )

		Next
	
	End
	
	Method EmitEnums( scope:Scope,kind:String )
	
		For Local node:=Eachin scope.nodes
	
			Local etype:=Cast<EnumType>( node.Value )
			If Not etype Continue
			
			Local decl:=etype.edecl
			If decl.kind<>kind Or DocsHidden( decl ) Continue
			
			_linkScope=etype.scope.outer

			EmitHeader( decl,etype.scope.outer )
		
			_md.Emit( "##### Enum "+DeclIdent( decl ) )
		
			_md.Emit( decl.docs )
		
			Local docs:=_md.Flush()

			Local page:=DeclPath( etype.edecl,etype.scope.outer )
			SavePage( docs,page )
			
			EmitLeaf( etype.edecl,page )
			
		Next
	
	End
	
	Method EmitClasses( scope:Scope,kind:String )
	
		For Local node:=Eachin scope.nodes
	
			Local ctype:=Cast<ClassType>( node.Value )
			If Not ctype Or ctype.transFile.module<>_module Continue
			
			Local decl:=ctype.cdecl
			If decl.kind<>kind Or DocsHidden( decl ) Continue
			
			_linkScope=ctype.scope	'.outer
			
			EmitHeader( decl,ctype.scope.outer )
			
			Local xtends:=""
			If ctype.superType
				If ctype.superType<>Type.ObjectClass
					xtends=" Extends "+TypeName( ctype.superType,ctype.scope.outer )
				Endif
			Else If ctype.isvoid
				xtends=" Extends Void"
			Endif
			
			Local implments:=""
			If decl.ifaceTypes
				Local ifaces:=""
				For Local iface:=Eachin ctype.ifaceTypes
					ifaces+=","+TypeName( iface,ctype.scope.outer )
				Next
				ifaces=ifaces.Slice( 1 )
				If decl.kind="interface"
					xtends=" Extends "+ifaces
				Else
					implments=" Implements "+ifaces
				Endif
			Endif
			
			Local mods:=""
			If decl.IsVirtual
				mods+=" Virtual"
			Else If decl.IsAbstract
				mods+=" Abstract"
			Else If decl.IsFinal
				mods+=" Final"
			Endif
			
			_md.Emit( "##### "+decl.kind.Capitalize()+" "+DeclIdent( decl,True )+xtends+implments+mods )
			
			_md.Emit( decl.docs )
			
			For Local inh:=0 Until 1
				EmitMembers( "alias",ctype.scope,inh )
				EmitMembers( "enum",ctype.scope,inh )
				EmitMembers( "struct",ctype.scope,inh )
				EmitMembers( "class",ctype.scope,inh )
				EmitMembers( "interface",ctype.scope,inh )
				EmitMembers( "const",ctype.scope,inh )
				EmitMembers( "global",ctype.scope,inh )
				EmitMembers( "field",ctype.scope,inh )
				EmitMembers( "property",ctype.scope,inh )
				EmitMembers( "constructor",ctype.scope,inh )
				EmitMembers( "operator",ctype.scope,inh )
				EmitMembers( "method",ctype.scope,inh )
				EmitMembers( "function",ctype.scope,inh )
			End
		
			Local docs:=_md.Flush()

			Local page:=DeclPath( ctype.cdecl,ctype.scope.outer )
			SavePage( docs,page )
			
			EmitNode( ctype.cdecl,ctype.scope,page )
		Next
	
	End
	
	Method EmitProperties( scope:Scope,kind:String )
	
		For Local node:=Eachin scope.nodes
		
			Local plist:=Cast<PropertyList>( node.Value )
			If Not plist Continue
			
			Local decl:=plist.pdecl
			If decl.kind<>kind Or DocsHidden( decl ) Continue

			Local func:=plist.getFunc
			If Not func 
				func=plist.setFunc
				If Not func Continue
			Endif

			Local type:=func.ftype.argTypes ? func.ftype.argTypes[1] Else func.ftype.retType
			
			_linkScope=func.scope
			
			EmitHeader( decl,func.scope )
			
			_md.Emit( "##### Property "+DeclIdent( decl )+" : "+TypeName( type,func.scope ) )
			
			_md.Emit( decl.docs )
			
			Local docs:=_md.Flush()
			
			Local page:=DeclPath( plist.pdecl,plist.scope )
			SavePage( docs,page )
			
			EmitLeaf( plist.pdecl,page )

		Next
	
	End
	
	Method EmitFuncs( scope:Scope,kind:String )
	
		For Local node:=Eachin scope.nodes
		
			Local flist:=Cast<FuncList>( node.Value )
			If Not flist Or Cast<PropertyList>( flist ) Continue
			
			Local buf:StringStack
					
			For Local func:=Eachin flist.funcs
				Local decl:=func.fdecl
				
				If DocsHidden( decl ) Continue
				
				If kind="constructor"
					If decl.ident<>"new" Continue
				Else If kind="operator"
					If Not decl.IsOperator Continue
				Else If kind<>decl.kind Or decl.ident="new" Or decl.IsOperator
					Continue
				Endif
				
				_linkScope=func.scope
				
				If Not buf
					buf=New StringStack
					EmitHeader( decl,func.scope )
				Endif
				
				buf.Push( decl.docs )
				
				Local tkind:=decl.kind.Capitalize()+" "
				If decl.IsOperator tkind=""
				
				Local params:=""
				For Local i:=0 Until func.ftype.argTypes.Length
					Local ident:=Esc( func.fdecl.type.params[i].ident )
					Local type:=TypeName( func.ftype.argTypes[i],func.scope )
					Local init:=""
					If func.fdecl.type.params[i].init
						init=" ="+func.fdecl.type.params[i].init.ToString()
					Endif
					params+=" , "+ident+" : "+type+init
				Next
				params=params.Slice( 3 )
				
				_md.Emit( "##### "+tkind+DeclIdent( decl,True )+" : "+TypeName( func.ftype.retType,func.scope )+" ( "+params+" ) " )
	
			Next
			
			If Not buf Continue
			
			For Local doc:=Eachin buf
				_md.Emit( doc )
			Next
		
			Local docs:=_md.Flush()
			
			Local page:=DeclPath( flist.funcs[0].fdecl,flist.funcs[0].scope )
			SavePage( docs,page )
			
			EmitLeaf( flist.funcs[0].fdecl,page )
			
		Next
	
	End
	
End
	
